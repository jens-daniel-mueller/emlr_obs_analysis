---
title: "Column inventories"
author: "Jens Daniel MÃ¼ller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
---

```{r parent, child = "/nfs/kryo/work/jenmueller/emlr_cant/utilities/setup.Rmd"}
# this chunk runs the code stored in setup.Rmd
# if required, please refer to instructions given here:
# https://jdblischak.github.io/workflowr/articles/wflow-07-common-code.html
```

```{r define_paths, include = FALSE}

# only path_observations needs to be changed to model
path_observations <-
  paste(path_root, "/observations/", sep = "")

path_preprocessing    <-
  paste(path_observations, "preprocessing/", sep = "")


path_preprocessing_model    <-
  paste(path_root, "/model/preprocessing/", sep = "")

```

```{r load_libraries_specific, include = FALSE}
library(patchwork)
library(marelac)
```

# Data sources

Following Cant estimates are used:

- Zonal mean (basin, lat, depth)
- Inventories (lat, lon)

```{r read_files}

Version_IDs <- list.files(
  path = "/nfs/kryo/work/jenmueller/emlr_cant/observations",
  pattern = "v_1")

Version_IDs <- Version_IDs[1:8]

for (i_Version_IDs in Version_IDs) {
  # i_Version_IDs <- Version_IDs[1]
  
  print(i_Version_IDs)
  
  path_version_data     <-
  paste(path_observations,
        i_Version_IDs,
        "/data/",
        sep = "")
  
  cant_inv <-
    read_csv(paste(path_version_data,
                   "cant_inv.csv",
                   sep = ""))
  
  cant_inv_mod_truth <-
    read_csv(paste(path_version_data,
                   "cant_inv_mod_truth.csv",
                   sep = ""))
  
  cant_inv <- bind_rows(cant_inv, cant_inv_mod_truth)
  
  cant_inv <- cant_inv %>% 
    mutate(Version_ID = i_Version_IDs)
  
  params_local <-
    read_rds(paste(path_version_data,
                   "params_local.rds",
                   sep = ""))
  
  params_local <- bind_cols(
    Version_ID = i_Version_IDs,
    MLR_basins = params_local$MLR_basins,
    dup_era1 = str_c(params_local$dup_era1, collapse = "-")
  )
  
  cant_inv <- full_join(cant_inv, params_local)
  
  tref <- read_csv(paste(path_version_data,
                         "tref.csv",
                         sep = ""))
  
  duration <- sort(tref$median_year)[2] - sort(tref$median_year)[1]
  
  cant_inv <- cant_inv %>% 
    mutate(duration = duration)
  
  if (exists("cant_inv_all")) {
    cant_inv_all <- bind_rows(cant_inv_all, cant_inv)
  }
  
  if (!exists("cant_inv_all")) {
    cant_inv_all <- cant_inv
  }
  
  
}


```


```{r filter_standard_inventory_depth}

cant_inv_all <- cant_inv_all %>%
  filter(inv_depth == params_global$inventory_depth_standard)

```


```{r column_inventory_maps_output, fig.asp=1}

cant_inv_all_bias <- cant_inv_all %>%
  select(lat, lon, data_source, Version_ID, dup_era1, MLR_basins, cant_inv) %>%
  pivot_wider(names_from = data_source,
              values_from = cant_inv) %>%
  mutate(cant_bias = mod - mod_truth) %>%
  drop_na()

cant_inv_all_bias %>%
  p_map_cant_inv(var = "obs",
                 col = "divergent") +
  facet_grid(MLR_basins ~ dup_era1)


cant_inv_all_bias %>%
  p_map_cant_inv(var = "cant_bias",
                 col = "divergent",
                 subtitle_text = "data_source: mod - mod_truth") +
  facet_grid(MLR_basins ~ dup_era1)

```

```{r budgets_regional, fig.asp=1}

cant_inv_budget <- cant_inv_all %>% 
  mutate(surface_area = earth_surf(lat, lon),
         cant_inv_grid = cant_inv*surface_area,
         cant_pos_inv_grid = cant_pos_inv*surface_area) %>% 
  group_by(basin_AIP, data_source, Version_ID, MLR_basins, dup_era1, duration) %>% 
  summarise(cant_total = sum(cant_inv_grid)*12*1e-15,
            cant_total = round(cant_total,1),
            cant_pos_total = sum(cant_pos_inv_grid)*12*1e-15,
            cant_pos_total = round(cant_pos_total,1)) %>% 
  ungroup()

cant_inv_budget %>%
  group_by(data_source, Version_ID) %>%
  summarise(cant_total = sum(cant_total),
            cant_total = round(cant_total,1),
            cant_pos_total = sum(cant_pos_total),
            cant_pos_total = round(cant_pos_total,1),
            cant_total_rate = cant_total / duration,
            cant_pos_total_rate = cant_pos_total / duration) %>%
  ungroup()

cant_inv_budget %>%
  ggplot(aes(data_source, cant_total/duration, fill = basin_AIP)) +
  scale_fill_brewer(palette = "Dark2") +
  geom_col() +
  facet_grid(MLR_basins ~ dup_era1)

```


```{r budget_global}

cant_inv_budget %>%
  filter(data_source == "obs") %>% 
  group_by(MLR_basins, dup_era1) %>% 
  summarise(rate = sum(cant_total/duration)) %>% 
  ungroup() %>% 
  ggplot(aes(dup_era1, rate, fill=MLR_basins)) +
  geom_bar(stat="identity", position=position_dodge()) +
  scale_y_continuous() +
  scale_fill_brewer(palette = "Set1")

```



```{r column_inventory_maps, eval=FALSE}

cant_inv_all %>%
  filter(data_source == "obs") %>% 
  group_split(Version_ID) %>%
  map(
    ~ p_map_cant_inv(
    df = .x,
    var = "cant_inv",
    subtitle_text = paste("Version_ID:", unique(.x$Version_ID))
  ))


cant_inv_all_bias %>%
  group_split(Version_ID) %>%
  map(
    ~ p_map_cant_inv(
      df = .x,
      var = "cant_bias",
      col = "divergent",
      subtitle_text = "data_source: mod - mod_truth"
    )
  )

```


