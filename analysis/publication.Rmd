---
title: "Materials for publication"
author: "Jens Daniel MÃ¼ller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
---

```{r parent, child = "/nfs/kryo/work/jenmueller/emlr_cant/utilities/setup.Rmd"}
# this chunk runs the code stored in setup.Rmd
# if required, please refer to instructions given here:
# https://jdblischak.github.io/workflowr/articles/wflow-07-common-code.html
```

```{r define_paths, include = FALSE}

# only path_observations needs to be changed to model
path_observations <-
  paste(path_root, "/observations/", sep = "")

path_preprocessing    <-
  paste(path_observations, "preprocessing/", sep = "")


path_preprocessing_model    <-
  paste(path_root, "/model/preprocessing/", sep = "")

path_version_data     <-
  paste(path_observations,
        "v_XXX",
        "/data/",
        sep = "")

```

```{r load_libraries_specific, include = FALSE}
library(sf)
library(rnaturalearth)
library(ggnewscale)
```

# Data sources

Following Cant estimates are used:

- Zonal mean (basin, lat, depth)
- Inventories (lat, lon)

```{r read_files}

cant_inv <-
  read_csv(paste(path_version_data,
                 "cant_inv.csv",
                 sep = ""))

cant_inv_mod_truth <-
  read_csv(paste(path_version_data,
                 "cant_inv_mod_truth.csv",
                 sep = ""))

cant_inv <- bind_rows(cant_inv, cant_inv_mod_truth)

GLODAP_clean <-
  read_csv(paste(path_version_data,
                 "GLODAPv2.2020_clean.csv",
                 sep = ""))

GLODAP_preprocessed <-
  read_csv(
    paste(
      path_preprocessing_model,
      "GLODAPv2.2020_preprocessed_model_runA_both.csv",
      sep = ""
    )
  )

```


```{r filter_standard_inventory_depth}

cant_inv <- cant_inv %>%
  filter(inv_depth == params_global$inventory_depth_standard)

```

# Inventory map

```{r mask_and_shape_files}

coastlines <- ne_coastline(scale = "small", returnclass = "sf")
coastlines_re <- ne_coastline(scale = "small", returnclass = "sf")
worldmap <- ne_countries(scale = "small", returnclass = "sf")
worldmap_re <- ne_countries(scale = "small", returnclass = "sf")

crs <- st_crs(coastlines)

st_geometry(worldmap_re) <- st_geometry(worldmap_re) + c(360, 0)
st_crs(worldmap_re) <- crs
worldmap <- rbind(worldmap, worldmap_re)
rm(worldmap_re)

st_geometry(coastlines_re) <- st_geometry(coastlines_re) + c(360, 0)
st_crs(coastlines_re) <- crs
coastlines <- rbind(coastlines, coastlines_re)
rm(coastlines_re)

# coastlines_buffer <- st_buffer(coastlines, dist = 1)
# coastlines_re_buffer <- st_buffer(coastlines_re, dist = 1)

# coastline_raster <- stars::st_rasterize(coastlines, options = "ALL_TOUCHED=TRUE") %>% 
#   as.tibble()


ggplot() +
  geom_sf(data = worldmap, col = "transparent") +
  geom_sf(data = coastlines)


for (i_file in list.files("data/iho_marginal_seas")) {
  iho <- st_read(paste0("data/iho_marginal_seas/", i_file, "/iho.shp"))
  
  if (exists("marine_polys")) {
    marine_polys <- rbind(marine_polys, iho)
  } else {
    marine_polys <- iho
  }
  
}

marine_polys_re <- marine_polys
st_geometry(marine_polys_re) <- st_geometry(marine_polys) + c(360, 0)

st_crs(marine_polys) <- crs
st_crs(marine_polys_re) <- crs

marine_polys <- rbind(marine_polys, marine_polys_re)
rm(marine_polys_re)

ggplot() +
  geom_sf(data = marine_polys, fill = "white")

# marine_polys_simple <- st_simplify(marine_polys, dTolerance = 0.1)
# ggplot() +
#   geom_sf(data = marine_polys_simple, fill = "white")

black_sea <- st_read("data/black_sea/provinces.shp")
black_sea_re <- black_sea
st_geometry(black_sea_re) <- st_geometry(black_sea) + c(360, 0)
st_crs(black_sea) <- crs
st_crs(black_sea_re) <- crs
black_sea <- rbind(black_sea, black_sea_re)
rm(black_sea_re)

hudson_bay <- st_read("data/hudson_bay/lme.shp")
hudson_bay_re <- hudson_bay
st_geometry(hudson_bay_re) <- st_geometry(hudson_bay) + c(360, 0)
st_crs(hudson_bay) <- crs
st_crs(hudson_bay_re) <- crs
hudson_bay <- rbind(hudson_bay, hudson_bay_re)
rm(hudson_bay_re)

caspian_sea <- st_read("data/caspian_sea/seavox_v17.shp")
caspian_sea_re <- caspian_sea
st_geometry(caspian_sea_re) <- st_geometry(caspian_sea) + c(360, 0)
st_crs(caspian_sea) <- crs
st_crs(caspian_sea_re) <- crs
caspian_sea <- rbind(caspian_sea, caspian_sea_re)
rm(caspian_sea_re)

ggplot() +
  geom_sf(data = marine_polys, fill = "white") +
  geom_sf(data = black_sea, fill = "white") +
  geom_sf(data = caspian_sea, fill = "white") +
  geom_sf(data = hudson_bay, fill = "white")

```



```{r cant_inv_map}

var_name <- expression(atop(Delta * C["ant"],
                            (mol ~ m ^ {
                              -2
                            })))

GLODAP_grid <- GLODAP_clean %>% 
  distinct(lon, lat, era)

GLODAP_grid_both <- GLODAP_grid %>% 
  count(lon, lat) %>% 
  mutate(n = as.factor(n))

cant_inv %>%
  filter(data_source == "obs") %>% 
  ggplot(aes(cant_pos_inv)) +
  geom_histogram()


set_breaks <- c(-Inf, seq(0, 12, 2), Inf)

p_inv_map <- ggplot() +
  # geom_raster(
  #   data = cant_inv %>% filter(data_source == "obs"),
  #   aes(lon, lat), fill = "green") +
  geom_contour_fill(
    data = cant_inv %>% filter(data_source == "obs"),
    aes(lon, lat, z = cant_inv, fill = stat(level)),
    breaks = set_breaks,
    na.fill = TRUE
  ) +
  scale_fill_viridis_d(option = "D", name = var_name,
                       guide = guide_colorsteps()) +
  new_scale_fill() +
  geom_tile(data = GLODAP_grid_both,
              aes(x = lon, y = lat, height = 0.7, width = 0.7, fill=n)) +
  scale_fill_manual(values = c("deeppink4", "deeppink"),
                    name = "Eras\noccupied") +
  geom_sf(data = marine_polys, fill = "white", col="white") +
  geom_sf(data = black_sea, fill = "white", col="white") +
  geom_sf(data = caspian_sea, fill = "white", col="white") +
  geom_sf(data = hudson_bay, fill = "white", col="white") +
  geom_sf(data = worldmap, fill="grey80", color="transparent") +
  geom_sf(data = coastlines, col = "black") +
  coord_sf(ylim = c(-77.5,64.5), xlim = c(20.5,379.5), expand = 0) +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        legend.key = element_rect(colour = "black"))


ggsave(plot = p_inv_map,
       path = "output/publication",
       filename = "dCant_inventory_map.png",
       height = 4,
       width = 10)

```


# Data time series histogram

```{r time_series}

time_histo <- GLODAP_preprocessed %>% 
  filter(!is.na(tco2)) %>% 
  count(basin_AIP, year)

time_histo %>% 
  ggplot(aes(year, n, fill=basin_AIP)) + 
  geom_col() +
  scale_fill_brewer(palette = "Dark2") +
  scale_x_continuous(breaks = seq(1900,2100,5)) +
  scale_y_continuous(name = "") +
  coord_cartesian(expand = 0) +
  labs(title = "GLODAPv2.2020 | Observations coverage")

```

# Spatial time coverage

```{r time_series_maps}

time_histo <- GLODAP_preprocessed %>% 
  filter(year >= 2000) %>% 
  distinct(lat, lon, year)

map + 
  geom_raster(data = time_histo, aes(lon, lat)) +
  facet_wrap(~ year)

```

# Model offset


```{r plotting_tools, eval=FALSE}


GLODAP_sp <- GLODAP %>% 
  filter(depth == 150)

map +
  geom_raster(data = GLODAP_sp,
              aes(lon, lat, fill = temp)) +
  scale_fill_viridis_c()

class(GLODAP_sp)

GLODAP_sp <- GLODAP_sp %>% 
  mutate(lon = if_else(lon > 180, lon - 360, lon))

ggplot() +
  geom_raster(data = GLODAP_sp,
              aes(lon, lat, fill = temp)) +
  scale_fill_viridis_c() +
  coord_quickmap()

GLODAP_sp <- as.data.frame(GLODAP_sp)

library(sp)
coordinates(GLODAP_sp) = ~lon+lat
class(GLODAP_sp)

summary(GLODAP_sp)

is.projected(GLODAP_sp)
proj4string(GLODAP_sp) <-
  CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")


GLODAP_sp_grid <- GLODAP_sp

gridded(GLODAP_sp_grid) <- TRUE


spplot(GLODAP_sp,
       zcol = "temp")

spplot(GLODAP_sp_grid,
       zcol = "temp")

library(sf)
library(stars)
GLODAP_sf <- st_as_sf(GLODAP_sp_grid)
GLODAP_stars <- st_as_stars(GLODAP_sp_grid)
class(GLODAP_stars)

plot(GLODAP_stars)

ggplot() +
  geom_stars(data = GLODAP_stars,
             aes(x, y, fill = temp)) +
  scale_fill_viridis_c(na.value = "transparent") +
  coord_quickmap(expand = 0)


coastlines <- ne_coastline(scale = "small", returnclass = "sf")

ggplot() +
  geom_sf(data = GLODAP_sf,
             aes(col = temp)) +
  scale_fill_viridis_c(na.value = "transparent") +
  geom_sf(data = st_wrap_dateline(coastlines),
          colour = "black") +
  coord_sf(crs = st_crs('ESRI:54030')) +
  theme_bw()

summary(GLODAP_sp)


```

