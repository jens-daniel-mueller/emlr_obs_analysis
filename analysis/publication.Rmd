---
title: "Materials for publication"
author: "Jens Daniel MÃ¼ller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
---

```{r parent, child = "/nfs/kryo/work/jenmueller/emlr_cant/utilities/setup.Rmd"}
# this chunk runs the code stored in setup.Rmd
# if required, please refer to instructions given here:
# https://jdblischak.github.io/workflowr/articles/wflow-07-common-code.html
```

```{r define_paths, include = FALSE}

# only path_observations needs to be changed to model
path_observations <-
  paste(path_root, "/observations/", sep = "")

path_preprocessing    <-
  paste(path_observations, "preprocessing/", sep = "")


path_preprocessing_model    <-
  paste(path_root, "/model/preprocessing/", sep = "")

path_version_data     <-
  paste(path_observations,
        "v_XXX",
        "/data/",
        sep = "")

```

```{r load_libraries_specific, include = FALSE}
library(sf)
library(rnaturalearth)
library(ggnewscale)
```

# Data sources

Following Cant estimates are used:

- Zonal mean (basin, lat, depth)
- Inventories (lat, lon)

```{r read_files}

cant_inv <-
  read_csv(paste(path_version_data,
                 "cant_inv.csv",
                 sep = ""))

cant_inv_mod_truth <-
  read_csv(paste(path_version_data,
                 "cant_inv_mod_truth.csv",
                 sep = ""))

cant_inv <- bind_rows(cant_inv, cant_inv_mod_truth)


cant_zonal <-
  read_csv(paste(path_version_data,
                 "cant_zonal.csv",
                 sep = ""))

cant_zonal_mod_truth <-
  read_csv(paste(path_version_data,
                 "cant_zonal_mod_truth.csv",
                 sep = ""))

cant_zonal <- bind_rows(cant_zonal,
                        cant_zonal_mod_truth)




GLODAP_clean <-
  read_csv(paste(path_version_data,
                 "GLODAPv2.2020_clean.csv",
                 sep = ""))

GLODAP_preprocessed <-
  read_csv(
    paste(
      path_preprocessing_model,
      "GLODAPv2.2020_preprocessed_model_runA_both.csv",
      sep = ""
    )
  )

GLODAP_grid_dup <-
  read_csv(paste(path_version_data,
                  "GLODAPv2.2020_clean_obs_grid_duplicates.csv",
                  sep = ""))

```


```{r filter_standard_inventory_depth}

cant_inv <- cant_inv %>%
  filter(inv_depth == params_global$inventory_depth_standard)

```

# Inventory map

```{r mask_and_shape_files}

# coastlines and worldmap

coastlines <- ne_coastline(scale = "small", returnclass = "sf")
coastlines_re <- ne_coastline(scale = "small", returnclass = "sf")
worldmap <- ne_countries(scale = "small", returnclass = "sf")
worldmap_re <- ne_countries(scale = "small", returnclass = "sf")

crs <- st_crs(coastlines)

st_geometry(worldmap_re) <- st_geometry(worldmap_re) + c(360, 0)
st_crs(worldmap_re) <- crs
worldmap <- rbind(worldmap, worldmap_re)
rm(worldmap_re)

st_geometry(coastlines_re) <- st_geometry(coastlines_re) + c(360, 0)
st_crs(coastlines_re) <- crs
coastlines <- rbind(coastlines, coastlines_re)
rm(coastlines_re)

# coastlines_buffer <- st_buffer(coastlines, dist = 1)
# coastlines_re_buffer <- st_buffer(coastlines_re, dist = 1)

# coastline_raster <- stars::st_rasterize(coastlines, options = "ALL_TOUCHED=TRUE") %>% 
#   as.tibble()


# unmapped regions shape files

for (i_file in list.files("data/iho_marginal_seas")) {
  iho <- st_read(paste0("data/iho_marginal_seas/", i_file, "/iho.shp"))
  
  if (exists("marine_polys")) {
    marine_polys <- rbind(marine_polys, iho)
  } else {
    marine_polys <- iho
  }
  
}

marine_polys_re <- marine_polys
st_geometry(marine_polys_re) <- st_geometry(marine_polys) + c(360, 0)

st_crs(marine_polys) <- crs
st_crs(marine_polys_re) <- crs

marine_polys <- rbind(marine_polys, marine_polys_re)
rm(marine_polys_re)

# plot(st_geometry(marine_polys))
# ggplot() +
#   geom_sf(data = st_geometry(marine_polys), fill = "white")

# marine_polys_simple <- st_simplify(marine_polys, dTolerance = 0.5)
# ggplot() +
#   geom_sf(data = marine_polys, fill = "red") +
#   geom_sf(data = marine_polys_simple, fill = "white")

black_sea <- st_read("data/black_sea/provinces.shp")
black_sea_re <- black_sea
st_geometry(black_sea_re) <- st_geometry(black_sea) + c(360, 0)
st_crs(black_sea) <- crs
st_crs(black_sea_re) <- crs
black_sea <- rbind(black_sea, black_sea_re)
rm(black_sea_re)

hudson_bay <- st_read("data/hudson_bay/lme.shp")
hudson_bay_re <- hudson_bay
st_geometry(hudson_bay_re) <- st_geometry(hudson_bay) + c(360, 0)
st_crs(hudson_bay) <- crs
st_crs(hudson_bay_re) <- crs
hudson_bay <- rbind(hudson_bay, hudson_bay_re)
rm(hudson_bay_re)

caspian_sea <- st_read("data/caspian_sea/seavox_v17.shp")
caspian_sea_re <- caspian_sea
st_geometry(caspian_sea_re) <- st_geometry(caspian_sea) + c(360, 0)
st_crs(caspian_sea) <- crs
st_crs(caspian_sea_re) <- crs
caspian_sea <- rbind(caspian_sea, caspian_sea_re)
rm(caspian_sea_re)

# ggplot() +
#   geom_sf(data = marine_polys, fill = "white") +
#   geom_sf(data = black_sea, fill = "white") +
#   geom_sf(data = caspian_sea, fill = "white") +
#   geom_sf(data = hudson_bay, fill = "white")

```



```{r cant_inv_map}

set_breaks <- c(-Inf, seq(0, 12, 2), Inf)
color_land <- "grey80"
color_unmapped <- "grey90"

var_name <- expression(atop(Delta * C["ant"],
                            (mol ~ m ^ {
                              -2
                            })))

GLODAP_grid_both <- GLODAP_grid_dup %>%
  filter(duplicate == "no") %>% 
  count(lon, lat) %>% 
  mutate(n = as.factor(n))


p_inv_map <- ggplot() +
  geom_contour_fill(
    data = cant_inv %>% filter(data_source == "obs"),
    aes(lon, lat, z = cant_inv, fill = stat(level)),
    breaks = set_breaks,
    na.fill = TRUE
  ) +
  scale_fill_viridis_d(option = "D", name = var_name,
                       guide = guide_colorsteps()) +
  new_scale_fill() +
  geom_tile(data = GLODAP_grid_both,
              aes(x = lon, y = lat, height = 0.7, width = 0.7, fill=n)) +
  scale_fill_manual(values = c("Deeppink4", "Deeppink"),
                    name = "Eras\noccupied") +
  geom_sf(data = marine_polys, fill = color_unmapped, col="transparent") +
  geom_sf(data = black_sea,  fill = color_unmapped, col="transparent") +
  geom_sf(data = caspian_sea,  fill = color_unmapped, col="transparent") +
  geom_sf(data = hudson_bay, fill = "white", col="white") +
  geom_sf(data = worldmap,  fill = color_land, col="transparent") +
  geom_sf(data = coastlines, col = "black") +
  coord_sf(ylim = c(-77.5,64.5), xlim = c(20.5,379.5), expand = 0) +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        legend.key = element_rect(colour = "black"))


ggsave(plot = p_inv_map,
       path = "output/publication",
       filename = "dCant_inventory_map.png",
       height = 4,
       width = 10)

```

# Spatial time coverage

```{r time_series_maps}

time_histo <- GLODAP_preprocessed %>%
  filter(year >= 2000) %>%
  distinct(lat, lon, year)

p_coverage_maps <- 
map +
  geom_raster(data = time_histo, aes(lon, lat)) +
  facet_wrap( ~ year) +
  theme(
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    axis.title = element_blank()
  )


ggsave(plot = p_coverage_maps,
       path = "output/publication",
       filename = "data_coverage_maps_by_year.png",
       height = 7,
       width = 16)

```



# Data time series histogram

```{r time_series}

time_histo <- GLODAP_preprocessed %>% 
  filter(!is.na(tco2)) %>% 
  count(basin_AIP, year)

time_histo %>% 
  ggplot(aes(year, n)) + 
  geom_col() +
  scale_fill_brewer(palette = "Dark2") +
  scale_x_continuous(breaks = seq(1900,2100,5)) +
  scale_y_continuous(name = "") +
  coord_cartesian(expand = 0) +
  labs(title = "GLODAPv2.2020 | Observations coverage") +
  theme_bw() +
  theme(axis.title = element_blank())

ggsave(path = "output/publication",
       filename = "histogram_observations.png",
       height = 2,
       width = 10)

```



```{r cant_inv_map_color_only, eval=FALSE}

color_land <- "white"
color_unmapped <- "white"

p_inv_map <- ggplot() +
  geom_contour_fill(
    data = cant_inv %>% filter(data_source == "obs"),
    aes(lon, lat, z = cant_inv, fill = stat(level)),
    breaks = set_breaks,
    na.fill = TRUE
  ) +
  scale_fill_viridis_d(option = "D", name = var_name,
                       guide = FALSE) +
  geom_sf(data = marine_polys, fill = color_unmapped, col="transparent") +
  geom_sf(data = black_sea,  fill = color_unmapped, col="transparent") +
  geom_sf(data = caspian_sea,  fill = color_unmapped, col="transparent") +
  geom_sf(data = hudson_bay, fill = "white", col="white") +
  geom_sf(data = worldmap,  fill = color_land, col="transparent") +
  geom_sf(data = coastlines, col = "white") +
  coord_sf(ylim = c(-77.5,64.5), xlim = c(20.5,379.5), expand = 0) +
  theme_void()


ggsave(plot = p_inv_map,
       path = "output/publication",
       filename = "dCant_inventory_map_color_only.png",
       height = 4,
       width = 10)

```


# Zonal mean sections

```{r zonal_mean_sections_obs}

breaks <- c(-Inf, seq(0, 10, 1), Inf)
breaks_n <- length(breaks) - 1

legend_title = expression(atop(Delta * C[ant, pos],
                               (mu * mol ~ kg ^ {
                                 -1
                               })))

i_basin_AIP <- "Atlantic"

# plot base section
section <-
  cant_zonal %>%
  filter(basin_AIP == i_basin_AIP,
         data_source == "obs") %>%
  ggplot() +
  guides(fill = guide_colorsteps(barheight = unit(8, "cm"))) +
  scale_y_reverse() +
  scale_x_continuous(breaks = seq(-100, 100, 20),
                     limits = c(-85, 85)) +
  geom_contour_filled(aes(lat, depth, z = cant_mean),
                      breaks = breaks) +
  scale_fill_viridis_d(name = legend_title)



# select slab breaks for plotted basin
# if (i_basin_AIP == "Atlantic") {
#   slab_breaks <- params_local$slabs_Atl
# } else {
#   slab_breaks <- params_local$slabs_Ind_Pac
# }
# 
# 
# section <- section  +
#   geom_hline(yintercept = params_local$depth_min,
#              col = "white",
#              linetype = 2) +
#   geom_contour(aes(lat, depth, z = !!gamma),
#                breaks = slab_breaks,
#                col = "black") +
#   geom_text_contour(
#     aes(lat, depth, z = !!gamma),
#     breaks = slab_breaks,
#     col = "black",
#     skip = drop_slabs
#   )
# }

# cut surface water section
surface <-
  section +
  coord_cartesian(expand = 0,
                  ylim = c(500, 0)) +
  labs(y = "Depth (m)",
       title = i_basin_AIP) +
  theme(
    axis.title.x = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  )

# cut deep water section
deep <-
  section +
  coord_cartesian(expand = 0,
                  ylim = c(params_global$plotting_depth, 500)) +
  labs(x = expression(latitude ~ (degree * N)), y = "Depth (m)")


# combine surface and deep water section
section_combined <-
  surface / deep +
  plot_layout(guides = "collect")


ggsave(plot = section_combined,
       path = "output/publication",
       filename = "zonal_mean_section_obs.png",
       height = 4,
       width = 8)


```



# Model offset


```{r plotting_tools, eval=FALSE}


GLODAP_sp <- GLODAP %>% 
  filter(depth == 150)

map +
  geom_raster(data = GLODAP_sp,
              aes(lon, lat, fill = temp)) +
  scale_fill_viridis_c()

class(GLODAP_sp)

GLODAP_sp <- GLODAP_sp %>% 
  mutate(lon = if_else(lon > 180, lon - 360, lon))

ggplot() +
  geom_raster(data = GLODAP_sp,
              aes(lon, lat, fill = temp)) +
  scale_fill_viridis_c() +
  coord_quickmap()

GLODAP_sp <- as.data.frame(GLODAP_sp)

library(sp)
coordinates(GLODAP_sp) = ~lon+lat
class(GLODAP_sp)

summary(GLODAP_sp)

is.projected(GLODAP_sp)
proj4string(GLODAP_sp) <-
  CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")


GLODAP_sp_grid <- GLODAP_sp

gridded(GLODAP_sp_grid) <- TRUE


spplot(GLODAP_sp,
       zcol = "temp")

spplot(GLODAP_sp_grid,
       zcol = "temp")

library(sf)
library(stars)
GLODAP_sf <- st_as_sf(GLODAP_sp_grid)
GLODAP_stars <- st_as_stars(GLODAP_sp_grid)
class(GLODAP_stars)

plot(GLODAP_stars)

ggplot() +
  geom_stars(data = GLODAP_stars,
             aes(x, y, fill = temp)) +
  scale_fill_viridis_c(na.value = "transparent") +
  coord_quickmap(expand = 0)


coastlines <- ne_coastline(scale = "small", returnclass = "sf")

ggplot() +
  geom_sf(data = GLODAP_sf,
             aes(col = temp)) +
  scale_fill_viridis_c(na.value = "transparent") +
  geom_sf(data = st_wrap_dateline(coastlines),
          colour = "black") +
  coord_sf(crs = st_crs('ESRI:54030')) +
  theme_bw()

summary(GLODAP_sp)


```

